////////////////////////////////////////////////////////////////////////
//
// Select.java
//
// This file was generated by MapForce 2011r3sp1.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the MapForce Documentation for further details.
// http://www.altova.com/mapforce
//
////////////////////////////////////////////////////////////////////////

package com.altova.text.edi;

import java.io.IOException;
import java.util.ArrayList;

import com.altova.text.Generator;
import com.altova.text.ITextNode;
import com.altova.text.ITextNodeList;
import com.altova.text.edi.Parser.Context;

public class Select extends StructureItem {

	private String msField;
	private String msPrefix;
	//private String msType;

	public Select (String name, String sPrefix, String sField, String sType, Particle[] children) {
		super(name, ITextNode.Select, children);
		msPrefix = sPrefix;
		msField = sField;
		//msType = sType;
	}
	
	@Override
	public boolean read(Context context) {
		Scanner tmpScanner = new Scanner( context.getScanner().mText, context.getScanner().getServiceChars(), context.getParser().getEDIKind());
		tmpScanner.setCurrentState( context.getScanner().getCurrentState() );
		Generator tmpGenerator = new Generator();
		EDISemanticValidator tmpValidator = new EDISemanticValidator(context.getParser().getSettings() );
		Context preScanCtx = (new Parser()).new Context( context.getParser(), tmpScanner, mChildren[0], tmpGenerator, tmpValidator);

		//backup parseinfo data
		Parser.ParseInfo parseInfoBackup = context.getParser().cloneParseInfo();
		if( mChildren[0].getNode().read(preScanCtx) )
		{
			String sMessage = preScanCtx.getGenerator().getNodeValueByPath(msField);

     		//restore parseinfo
     		context.getParser().setParseInfo(parseInfoBackup);
     		if( sMessage != null && sMessage.length() > 0 )
			{
				ArrayList<Message> filtered = context.getParser().filterMessages(sMessage);
				for( int i = 0 ; i < filtered.size() ; ++i )
				{
					Message m = filtered.get( i );
					if (m.getRootParticle().getNode().read( context.newContext( context, m.getRootParticle() ) ))
						return true;
				}
     		}

  			throw new com.altova.AltovaException ("Message type '" + sMessage + "' unknown.");
		}

   		//restore parseinfo
   		context.getParser().setParseInfo(parseInfoBackup);

		return false;
	}

	@Override
	public void write(Writer writer, ITextNode node, Particle particle) throws IOException {
		boolean anyMessageWritten = false;
		for (String key : writer.mMessages.keySet()) {
			ITextNodeList children = node.getChildren().filterByName(msPrefix + writer.mMessages.get(key).getMessageType());
			for( int i = 0; i < children.size(); i++ )
			{
				writer.mValidator.setCurrentMessageType( key );
				Particle p = writer.mMessages.get(key).getRootParticle();
				p.getNode().write(writer, children.getAt(i), p);
				anyMessageWritten = true;
			}
		}

		if( !anyMessageWritten )
		{
			//report error/warning
			writer.handleError(
					 node,
					 Parser.ErrorType.MissingGroup,
					 ErrorMessages.GetMissingGroupMessage("Message")
			);
		}
	}

}
